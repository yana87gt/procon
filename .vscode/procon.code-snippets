{
    "dijkstra": {
        "prefix": "lib-dijkstra",
        "scope": "cpp",
        "body": [
            "using Cost = int;",
            "struct Edge{",
            "    Cost cost;",
            "    int to;",
            "    bool operator>(const Edge &right)const{",
            "        return cost > right.cost;",
            "    }",
            "};",
            "",
            "void dijkstra(vector<vector<Edge>> &g, Edge start){",
            "    vector<Cost> dp(g.size(), (Cost)INF);",
            "    priority_queue<Edge,vector<Edge>,greater<Edge>> qu;",
            "    dp[start.to] = start.cost;",
            "    qu.push(start);",
            "    while(qu.size()){",
            "        Edge cur = qu.top(); qu.pop();",
            "        int v = cur.to;",
            "        if(dp[v] < cur.cost) continue;",
            "        for(Edge e : g[v]){",
            "            if( dp[e.to] > cur.cost + e.cost){",
            "                dp[e.to] = cur.cost + e.cost;",
            "                qu.push({dp[e.to], e.to});",
            "            }",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "factorize": {
        "prefix": "lib-factorize",
        "scope": "cpp",
        "body": [
            "template<typename T> ",
            "map<T,int> factorize(T x){",
            "    map<T,int> mp;",
            "    for (T i = 2; i*i <= x; i++){",
            "        while (x%i == 0) {",
            "            x /= i;",
            "            mp[i]++;",
            "        }",
            "        if (x == 1) break;",
            "    }",
            "    if (x != 1) mp[x]++;",
            "    return mp;",
            "}",
            ""
        ]
    },
    "stub": {
        "prefix": "stub",
        "scope": "cpp",
        "body": [
            "printf(\"Debug at %s : %d\\n\",__func__,__LINE__);"
        ]
    },
    "first": {
        "prefix": "first",
        "scope": "cpp",
        "body": [
            "first"
        ]
    },
    "snippet": {
        "prefix": "snippet",
        "scope": "cpp",
        "body": [
            "// -------- START : snippet -------- //",
            "",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "struct IoSetup {",
            "    IoSetup() {",
            "        cin.tie(nullptr);",
            "        ios::sync_with_stdio(false);",
            "        cout << fixed << setprecision(10);",
            "        cerr << fixed << setprecision(10);",
            "    }",
            "} iosetup;",
            "",
            "// -------- START : macro -------- //",
            "",
            "#define ll long long",
            "#define rep(i,n) for(int i=0;i<int(n);++i)",
            "#define rep1(i,n) for(int i=1;i<=int(n);++i)",
            "#define len(c) (ll)c.size()",
            "#define all(v) (v).begin(),(v).end()",
            "#define lb(v,x) (lower_bound(all(v),x)-v.begin())",
            "#define ub(v,x) (upper_bound(all(v),x)-v.begin())",
            "#define has(c,x) (c.find(x) != c.end())",
            "#define uniq(v) v.erase(unique(all(v)),v.end())",
            "#define bit(k) (1LL<<(k))",
            "#define INF int(1e9)",
            "",
            "template<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }",
            "template<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }",
            "",
            "// -------- END : macro -------- //",
            "",
            "// -------- START : debug macro -------- //",
            "",
            "template<class T,class U> ostream& operator<<(ostream& ost, const pair<T,U> &p) { ost << \"(\" << p.first << \", \" << p.second << \")\"; return ost; }",
            "#define ostream_container { ost << \"{\"; for(const auto &t : v) { if (&t != &*v.begin()) ost << \", \"; ost << t; } ost << \"}\"; return ost; }",
            "template<class T> ostream& operator<<(ostream &ost, const vector<T> &v) ostream_container",
            "template<class T> ostream& operator<<(ostream &ost, const set<T> &v) ostream_container",
            "template<class T,class U> ostream& operator<<(ostream &ost, const map<T,U> &v) ostream_container",
            "",
            "template<class H> void recursive_debug(string s, H h) {",
            "    cerr << \"\\033[33m\" << s << \" = \" << h << endl << \"\\033[m\";",
            "}",
            "template<class H,class... T> void recursive_debug(string s, H h, T... t) {",
            "    int comma = s.find(',');",
            "    cerr << \"\\033[33m\" << s.substr(0,comma) << \" = \" << h << \", \";",
            "    recursive_debug(s.substr(comma+1), t...);",
            "}",
            "#define debug(...) recursive_debug(#__VA_ARGS__, __VA_ARGS__)",
            "",
            "// -------- END : debug macro -------- //",
            "",
            "// -------- END : snippet -------- //",
            "",
            "int main(void) {",
            "",
            "    return 0;",
            "}",
            ""
        ]
    },
    "rep": {
        "prefix": "rep",
        "scope": "cpp",
        "body": [
            "rep(${1:i},${2:N})"
        ]
    },
    "segment_tree": {
        "prefix": "lib-SegmentTree",
        "scope": "cpp",
        "body": [
            "template <typename T>",
            "class SegmentTree{",
            "  public:",
            "    int n;",
            "    T element;",
            "    vector<T> dat;",
            "    function<T(T,T)> operate;",
            "",
            "    SegmentTree(){}",
            "    SegmentTree(int n_,T element_,function<T(T,T)> operate_){",
            "        element = element_;",
            "        operate = operate_;",
            "        n = 1;",
            "        while(n < n_) n *= 2;",
            "        dat = vector<T>(n*2,element);",
            "    }",
            "",
            "    void update(int k,T a){",
            "        k += n-1;",
            "        dat[k] = a;",
            "        while(k > 0){",
            "            k = (k-1)/2;",
            "            dat[k] = operate(dat[k*2+1],dat[k*2+2]);",
            "        }",
            "    }",
            "",
            "    T query(int a,int b,int k,int l,int r){",
            "        if(r<=a || b<=l) return element;",
            "        if(a<=l && r<=b) return dat[k];",
            "        T vl = query(a,b,k*2+1,l,(l+r)/2);",
            "        T vr = query(a,b,k*2+2,(l+r)/2,r);",
            "        return operate(vl,vr);",
            "    }",
            "",
            "    T query(int a,int b) { return query(a,b,0,0,n); }",
            "",
            "    T get(int k){ return query(k,k+1); }",
            "};",
            "",
            ""
        ]
    },
    "operator": {
        "prefix": "operator",
        "scope": "cpp",
        "body": [
            "bool operator<(const ${1:State} &rhs) const {",
            "    return ${2:cost} < rhs.${2:cost};",
            "}"
        ]
    },
    "longest_common_subsequence": {
        "prefix": "lib-lcs",
        "scope": "cpp",
        "body": [
            "template<typename T>",
            "T lcs(T a, T b) {",
            "    if (b.size() > a.size()) swap(a,b);",
            "    int I = a.size();",
            "    int J = b.size();",
            "    vector<vector<int>> dp(I+1, vector<int>(J+1));",
            "    for (int i = 1; i <= I; i++) {",
            "        for (int j = 1; j <= J; j++) {",
            "            if (a[i-1] == b[j-1]) dp[i][j] = dp[i-1][j-1] + 1;",
            "            else dp[i][j] = max(dp[i][j-1], dp[i-1][j]);",
            "        }",
            "    }",
            "",
            "    int cost = dp[I][J];",
            "    T result;",
            "    for (int i = I; i >= 1; i--) {",
            "        for (int j = J; j >= 1; j--) {",
            "            if(dp[i-1][j-1] == cost-1 && a[i-1] == b[j-1]) {",
            "                result.push_back(a[i-1]);",
            "                cost--;",
            "                break;",
            "            }",
            "        }",
            "    }",
            "    reverse(result.begin(), result.end());",
            "    return result;",
            "}",
            "",
            ""
        ]
    },
    "yes_no": {
        "prefix": "yes-no",
        "scope": "cpp",
        "body": [
            "cout << ((${1:}) ? \"${2:Yes}\" : \"${3:No}\") << endl;"
        ]
    },
    "cumulative_sum": {
        "prefix": "lib-cumulative_sum",
        "scope": "cpp",
        "body": [
            "template<typename T>",
            "vector<T> cumulative_sum(vector<T> &v) {",
            "    vector<T> sum(v.size() + 1);",
            "    rep(i,v.size()){",
            "        sum[i+1] = sum[i] + v[i];",
            "    }",
            "    return sum;",
            "}",
            ""
        ]
    },
    "comp": {
        "prefix": "lib-comp",
        "scope": "cpp",
        "body": [
            "bool comp(${1:Point} &lhs, ${1:Point} &rhs) { return ${2:(lhs.x != rhs.x ? lhs.x < rhs.x : lhs.y < rhs.y)}; }",
            ""
        ]
    },
    "second": {
        "prefix": "second",
        "scope": "cpp",
        "body": [
            "second"
        ]
    },
    "GCJ": {
        "prefix": "GCJ",
        "scope": "cpp",
        "body": [
            "int T;",
            "cin>>T;",
            "rep(_,T){",
            "    printf(\"Case #%d: \",_+1);",
            "    ${1:}",
            "}"
        ]
    },
    "vector": {
        "prefix": "vector",
        "scope": "cpp",
        "body": [
            "vector<${1:int}>"
        ]
    },
    "gcd": {
        "prefix": "lib-gcd",
        "scope": "cpp",
        "body": [
            "long long gcd(long long  a, long long  b) { return b==0 ? a : gcd(b,a%b); }",
            ""
        ]
    },
    "modint2": {
        "prefix": "new-modint",
        "scope": "cpp",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "class modint {",
            "  public:",
            "    using ll = long long;",
            "    ll num;",
            "    static const ll MOD = 1e9+7;",
            "    static vector<modint> factorial;",
            "",
            "    modint(): num(0) {};",
            "    modint(ll num_): num((num_ + MOD) % MOD) {",
            "        assert(num >= 0 && num < MOD);",
            "        cout << \"modint(ll num_)\" << num << endl;",
            "    }",
            "    modint(const modint &r): num(r.num) {",
            "        cout << \"modint(const modint &r)\" << num << endl;",
            "    }",
            "    operator ll() const { cout << \"operator ll()\" << num << endl; return num; }",
            "",
            "    template <typename T>",
            "    void check_type(const T &num_) const {",
            "        assert(num_ >= 0 && num_ < MOD);",
            "        static_assert(is_integral<T>() || is_same<T,modint>(), \"T is not integral.\");",
            "    }",
            "",
            "    template <typename T>",
            "    // modint operator+(const T &r) const { check_type(r); return modint(num + r); }",
            "    modint operator+(const T &r) const { check_type(r); return num + r; }",
            "    template <typename T>",
            "    modint operator-(const T &r) const { check_type(r); return num - r; }",
            "    template <typename T>",
            "    modint operator*(const T &r) const { check_type(r); return num * r; }",
            "    template <typename T>",
            "    modint operator/(const T &r) const { check_type(r); return num * pow(r, MOD-2); }",
            "",
            "    template <typename T>",
            "    modint operator+=(const T &r) { return *this = *this + r; }",
            "    template <typename T>",
            "    modint operator-=(const T &r) { return *this = *this - r; }",
            "    template <typename T>",
            "    modint operator*=(const T &r) { return *this = *this * r; }",
            "    template <typename T>",
            "    modint operator/=(const T &r) { return *this = *this / r; }",
            "",
            "    static modint pow(const modint &x, const ll &r) {",
            "        if(r == 0) return 1;",
            "        return pow(x*x, r/2) * (r&1 ? x : modint(1));",
            "    }",
            "",
            "    static modint fact(int n){",
            "        if((int)factorial.size() <= n) {",
            "            int size = factorial.size();",
            "            factorial.resize(n+1);",
            "            for (int k = size; k <= n; k++) {",
            "                factorial[k] = factorial[k-1] * k;",
            "            }",
            "        }",
            "        return factorial[n];",
            "    }",
            "",
            "    static modint C(int n, int r){",
            "        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);",
            "    }",
            "",
            "    friend istream& operator>>(istream& is, modint &r){",
            "        ll num_;",
            "        is >> num_;",
            "        r = num_;",
            "        return is;",
            "    }",
            "};",
            "vector<modint> modint::factorial = {1};",
            "#define fact(n) modint::fact(n)",
            "#define C(n,r) modint::C(n,r)",
            "#define H(a,b) C(a+b, a)",
            "",
            "",
            "int main(void){",
            "    modint res = 0;",
            "    cout << modint(334LL) + modint(1000000000LL) << endl;",
            "    return 0;",
            "}",
            ""
        ]
    },
    "inversion": {
        "prefix": "lib-inversion",
        "scope": "cpp",
        "body": [
            "template<typename T>",
            "class BIT {",
            "    public:",
            "    int n;",
            "    vector<T> dat; // i: [1,n]",
            "",
            "    BIT(int size): n(size+1), dat(vector<T>(n+1)) {}",
            "",
            "    void add(int i, T x) {",
            "        while (i <= n) {",
            "            dat[i] += x;",
            "            i += i & -i;",
            "        }",
            "    }",
            "",
            "    T sum(int i) {",
            "        T ret = 0;",
            "        while (i > 0) {",
            "            ret += dat[i];",
            "            i -= i & -i;",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    T range(int l, int r) {",
            "        return sum(r) - sum(l-1);",
            "    }",
            "};",
            "",
            "using ll = long long;",
            "",
            "// i < j, (v[i] op v[j]) を満たす(i,j)の組を数える",
            "template<typename T>",
            "ll inversion(vector<T> v, string op) {",
            "    assert(op == \"<=\" || op == \">=\" || op == \">\" || op == \"<\");",
            "    if (op == \">=\" || op == \"<\") {",
            "        reverse(v.begin(), v.end());",
            "    }",
            "",
            "    ll size = v.size();",
            "    vector<pair<T, int>> vp(size);",
            "    rep(i,size) {",
            "        vp[i] = {v[i],i};",
            "    }",
            "    sort(vp.begin(), vp.end());",
            "",
            "    // 小さい順に 1..size の連番を振る",
            "    vector<int> order(size);",
            "    rep(i,size) {",
            "        order[vp[i].second] = i+1;",
            "    }",
            "",
            "    // i < j, order[i] <= order[j] の個数を数える",
            "    ll result = 0;",
            "    BIT<ll> bt(size);",
            "    rep(i,size){",
            "        result += bt.sum(order[i]);",
            "        bt.add(order[i], 1);",
            "    }",
            "",
            "    if (op == \">\" || op == \"<\") {",
            "        return size*(size-1)/2 - result;",
            "    } else {",
            "        return result;",
            "    }",
            "}",
            "",
            ""
        ]
    },
    "Point": {
        "prefix": "lib-Point",
        "scope": "cpp",
        "body": [
            "typedef complex<double> Point;",
            "typedef vector<Point> VP;",
            "#define X real()",
            "#define Y imag()",
            "const double EPS = 1e-9;",
            "#define LE(n,m) ((n) < (m) + EPS)",
            "#define GE(n,m) ((n) + EPS > (m))",
            "#define EQ(n,m) (abs((n)-(m)) < EPS)",
            "#define ps_edge(PS,i) PS[i],PS[(i+1)%PS.size()]",
            "",
            "namespace std {",
            "    bool operator<(const Point a, const Point b) {",
            "        return a.X != b.X ? a.X < b.X : a.Y < b.Y;",
            "    }",
            "}",
            "",
            "double dot(Point a, Point b) {",
            "    return a.X*b.X + a.Y*b.Y;",
            "}",
            "",
            "double cross(Point a, Point b) {",
            "    return a.X*b.Y - a.Y*b.X;",
            "}",
            "",
            "int ccw(Point a, Point b, Point c) {",
            "    b -= a;  c -= a;",
            "    if (cross(b,c) >  EPS) return +1;  // counter clockwise",
            "    if (cross(b,c) < -EPS) return -1;  // clockwise",
            "    if (dot(b,c)   < -EPS) return +2;  // c--a--b on line",
            "    if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b",
            "    return 0;                          // a--c--b on line or a==c or b==c",
            "}",
            ""
        ]
    },
    "syakutori": {
        "prefix": "lib-syakutori",
        "scope": "cpp",
        "body": [
            "// 区間の長さは0以上であるとする    ",
            "int l = 0;",
            "rep(r,n){",
            "    /* 区間にa[r]を追加 */",
            "    while(l <= r && !(/* 区間[l,r+1)が成立 */)){",
            "        /* 区間からa[l]を除去 */",
            "        l++;",
            "    }",
            "    /* 区間[l,r+1)に対する処理 */",
            "}",
            "",
            "",
            "// 区間の長さは1以上であるとする    ",
            "int l = 0;",
            "rep(r,n){",
            "    /* 区間にa[r]を追加 */",
            "    while(l < r && !(/* 区間[l,r]が成立 */)){",
            "        /* 区間からa[l]を除去 */",
            "        l++;",
            "    }",
            "    /* 区間[l,r]に対する処理 */",
            "}",
            ""
        ]
    },
    "Imos2D": {
        "prefix": "lib-Imos2D",
        "scope": "cpp",
        "body": [
            "template <typename T>",
            "class Imos2D{",
            "  public:",
            "    int Y,X;",
            "    vector<vector<T>> s;",
            "",
            "    Imos2D(){}",
            "    ~Imos2D(){}",
            "    Imos2D(int Y_, int X_): Y(Y_),X(X_) {",
            "        s.resize(Y+1);",
            "        rep(y,Y+1) s[y].resize(X+1);",
            "    }",
            "",
            "    void add(int y,int x,int h,int w,T v){",
            "        s[y][x] += v;",
            "        s[y][x+w+1] -= v;",
            "        s[y+h+1][x] -= v;",
            "        s[y+h+1][x+w+1] += v;",
            "    }",
            "",
            "    void simulate(){",
            "        rep(y,Y)rep(x,X-1){",
            "            s[y][x+1] += s[y][x];",
            "        }",
            "        rep(y,Y-1)rep(x,X){",
            "            s[y+1][x] += s[y][x];",
            "        }",
            "    }",
            "    vector<T>& operator[](std::size_t y) &{ return s[y]; }",
            "};"
        ]
    },
    "centroid": {
        "prefix": "lib-centroid",
        "scope": "cpp",
        "body": [
            "#define MAXN 2010",
            "",
            "// 木のクラスを作って、中心とかいろいろ一緒にライブラリ化しような",
            "",
            "vector<int> g[MAXN];",
            "bool centroid[MAXN]; // 重心になったことがある",
            "int subSize[MAXN];   // ある頂点をrootとしたときの部分木のサイズ",
            "",
            "int getSubSize(int v, int p) {",
            "    int& sum = subSize[v];",
            "    sum = 1;",
            "    for(int ch : g[v]){",
            "        if (ch == p || centroid[ch]) continue;",
            "        sum += getSubSize(ch, v);",
            "    }",
            "    return sum;",
            "}",
            "",
            "vector<int> Centroid(const vector<vector<int>> &g) {",
            "    int n = g.size();",
            "    vector<int> centroid;",
            "    vector<int> sz(n);",
            "    function<void (int, int)> dfs = [&](int u, int prev) {",
            "        sz[u] = 1;",
            "        bool is_centroid = true;",
            "        for (auto v : g[u]) if (v != prev) {",
            "            dfs(v, u);",
            "            sz[u] += sz[v];",
            "            if (sz[v] > n / 2) is_centroid = false;",
            "        }",
            "        if (n - sz[u] > n / 2) is_centroid = false;",
            "        if (is_centroid) centroid.push_back(u);",
            "    };",
            "    dfs(0, -1);",
            "    return centroid;",
            "}",
            "",
            "// t: 分解された木のサイズ",
            "// secondが重心",
            "pair<int,int> getCentroid(int v, int p, int t) {",
            "    pair<int,int> ret(INF, -1);",
            "    // m: 頂点vを根にした時の部分木の中で最大のサイズ",
            "    int sum = 1, m = 0;",
            "    for(int ch : g[v]){",
            "        if (ch == p || centroid[ch]) continue;",
            "        m = max(m, subSize[ch]);",
            "        sum += subSize[ch];",
            "        ret = min(ret, getCentroid(ch, v, t));",
            "    }",
            "    m = max(m, t-sum);",
            "    ret = min(ret, pair<int,int>(m, v));",
            "    return ret;",
            "}",
            "",
            "// pから見てvへの辺を除去",
            "void eraseEdge(int v,int p){",
            "    rep(i,g[p].size())if(g[p][i]==v){",
            "        g[p].erase(g[p].begin()+i);",
            "    }",
            "}",
            "",
            "void solve(){",
            "    getSubSize(v,-1);",
            "    int c = getCentroid(v,-1,subSize[v]).second;",
            "    centroid[c] = true;",
            "}",
            ""
        ]
    },
    "bipartite_matching": {
        "prefix": "lib-bipartite_matching",
        "scope": "cpp",
        "body": [
            "bool dfs(int v,vector<vector<int>> &g,",
            "    vector<int> &match,vector<bool> &used){",
            "",
            "    used[v] = true;",
            "    for(int u : g[v]){",
            "        int w = match[u];",
            "        if(w<0 || (!used[w] && dfs(w,g,match,used))){",
            "            match[v] = u;",
            "            match[u] = v;",
            "            return true;",
            "        }",
            "    }",
            "    return false;",
            "}",
            " ",
            "int bipartite_matching(vector<vector<int>> &g){",
            "    int res = 0;",
            "    int V = g.size();",
            "    vector<int> match(V, -INF);",
            "    rep(v,V){",
            "        if(match[v] < 0){",
            "            vector<bool> used(V, false);",
            "            if(dfs(v,g,match,used)){",
            "                res++;",
            "            }",
            "        }",
            "    }",
            "    return res;",
            "}",
            ""
        ]
    },
    "lcm": {
        "prefix": "lib-lcm",
        "scope": "cpp",
        "body": [
            "long long gcd(long long  a, long long  b) { return b==0 ? a : gcd(b,a%b); }",
            "long long lcm(long long  a, long long  b) { return a/gcd(a,b)*b; }",
            ""
        ]
    },
    "modint": {
        "prefix": "lib-modint",
        "scope": "cpp",
        "body": [
            "class modint {",
            "  public:",
            "    using ll = long long;",
            "    ll num;",
            "    static const ll MOD = 1e9+7;",
            "    static vector<modint> factorial;",
            "",
            "    modint(): num(0) {};",
            "    modint(ll n_): num((n_ + MOD) % MOD) {}",
            "    modint(const modint &r): num(r.num) {}",
            "    operator ll() const { return (num+MOD)%MOD; }",
            "    friend istream& operator>>(istream& is, modint &r){",
            "        ll num_;",
            "        is >> num_;",
            "        r = num_;",
            "        return is;",
            "    }",
            "    modint operator+(const modint &r) const { return modint(num + r.num); }",
            "    modint operator-(const modint &r) const { return modint(num - r.num); }",
            "    modint operator*(const modint &r) const { return modint(num * r.num); }",
            "",
            "    template<typename T>",
            "    modint operator^(const T &r) const {",
            "        if(r == 0) return 1;",
            "        return (((*this)*(*this)) ^ (r/2)) * modint(r&1 ? num : 1);",
            "    }",
            "    modint operator/(const modint &r) const { return num * (r^(MOD-2)); }",
            "",
            "    modint operator+=(const modint &r) { return *this = *this + r; }",
            "    modint operator-=(const modint &r) { return *this = *this - r; }",
            "    modint operator*=(const modint &r) { return *this = *this * r; }",
            "    modint operator/=(const modint &r) { return *this = *this / r; }",
            "",
            "    template<typename T>",
            "    modint operator^=(const T &r) { return *this = *this ^ r; }",
            "",
            "    static modint pow(const modint x, ll r) {",
            "        return x^r;",
            "    }",
            "",
            "    static modint fact(int n){",
            "        if((int)factorial.size() <= n) {",
            "            int size = factorial.size();",
            "            factorial.resize(n+1);",
            "            for (int i = size; i <= n; i++) {",
            "                factorial[i] = factorial[i-1] * modint(i);",
            "            }",
            "        }",
            "        return factorial[n];",
            "    }",
            "",
            "    static modint C(ll n,ll r){",
            "        return n >= r ? fact(n)/(fact(n-r)*fact(r)) : modint(0);",
            "    }",
            "};",
            "vector<modint> modint::factorial = {1};",
            "#define fact(n) modint::fact(n)",
            "#define C(n,r) modint::C(n,r)",
            "#define H(a,b) C(a+b, a)",
            ""
        ]
    },
    "eratosthenes": {
        "prefix": "lib-eratosthenes",
        "scope": "cpp",
        "body": [
            "#define SIZE 1000010",
            "vector<bool> prime(SIZE,true);",
            "void init(){",
            "    prime[0] = prime[1] = false;",
            "    rep(i,SIZE){",
            "        if(!prime[i])continue;",
            "        for(int j=i*2;j<SIZE;j+=i){",
            "            prime[j] = false;",
            "        }",
            "    }",
            "}",
            "",
            ""
        ]
    },
    "unionfind": {
        "prefix": "lib-unionfind",
        "scope": "cpp",
        "body": [
            "struct UnionFind{",
            "    vector<int> par;",
            "    vector<int> sizes;",
            "    UnionFind(int n):par(n),sizes(n,1){ rep(i,n)par[i]=i; }",
            "",
            "    //find root of x",
            "    int find(int x){",
            "        if(x!=par[x]) par[x] = find(par[x]);",
            "        return par[x];",
            "    }",
            "",
            "    void unite(int x,int y){",
            "        x = find(x);",
            "        y = find(y);",
            "        if(x == y) return;",
            "        if(sizes[x] < sizes[y]) swap(x, y);",
            "        par[y] = x;",
            "        sizes[x] += sizes[y];",
            "    }",
            "",
            "    bool same(int x,int y){ return find(x) == find(y); }",
            "    int size(int x){ return sizes[find(x)]; }",
            "};"
        ]
    },
    "binary_indexed_tree": {
        "prefix": "lib-BIT",
        "scope": "cpp",
        "body": [
            "template<typename T>",
            "class BIT {",
            "    public:",
            "    int n;",
            "    vector<T> dat; // i: [1,n]",
            "",
            "    BIT(int size): n(size+1), dat(vector<T>(n+1)) {}",
            "",
            "    void add(int i, T x) {",
            "        while (i <= n) {",
            "            dat[i] += x;",
            "            i += i & -i;",
            "        }",
            "    }",
            "",
            "    T sum(int i) {",
            "        T ret = 0;",
            "        while (i > 0) {",
            "            ret += dat[i];",
            "            i -= i & -i;",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    T range(int l, int r) {",
            "        return sum(r) - sum(l-1);",
            "    }",
            "};",
            "",
            ""
        ]
    },
    "median_queue": {
        "prefix": "lib-MedianQueue",
        "scope": "cpp",
        "body": [
            "template <typename T>",
            "class MedianQueue{",
            "  public:",
            "    priority_queue<T,vector<T>> leftQ;",
            "    priority_queue<T,vector<T>,greater<T>> rightQ;",
            "    MedianQueue() {}",
            "    ~MedianQueue() {}",
            "    void push(T x) {",
            "        if (leftQ.empty() || x <= leftQ.top()) {",
            "            leftQ.push(x);",
            "        } else {",
            "            rightQ.push(x);",
            "        }",
            "    }",
            "    pair<T,T> median() {",
            "        while (abs((int)leftQ.size() - (int)rightQ.size()) > 1) {",
            "            if (leftQ.size() < rightQ.size()) {",
            "                leftQ.push(rightQ.top());",
            "                rightQ.pop();",
            "            } else {",
            "                rightQ.push(leftQ.top());",
            "                leftQ.pop();",
            "            }",
            "        }",
            "        if (leftQ.size() + 1 == rightQ.size()) {",
            "            return {rightQ.top(), rightQ.top()};",
            "        } else if (leftQ.size() == rightQ.size() + 1){",
            "            return {leftQ.top(), leftQ.top()};",
            "        } else {",
            "            return {leftQ.top(), rightQ.top()};",
            "        }",
            "    }",
            "    int size() {",
            "        return leftQ.size() + rightQ.size();",
            "    }",
            "};",
            "",
            ""
        ]
    }
}